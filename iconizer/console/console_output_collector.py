import threading
import subprocess
import os
from iconizer.win import sysprocess

CREATE_NO_WINDOW = 0x8000000
import iconizer.logsys.logDir as logDir
from iconizer.logsys.logSys import *
import traceback


class ConsoleCollectWorkerThread(threading.Thread):
    def __init__(self, target, fileD, appname='unknown', output_to_console=False, logFilePath=None):
        self.target = target
        threading.Thread.__init__(self)
        self.quitFlag = False
        self.fileD = fileD
        self.appname = appname
        self.output_to_console = output_to_console
        self.logFilePath = logFilePath

    def open_log_if_needed(self):
        if not (self.logFilePath is None):
            try:
                f = open(self.logFilePath, "w")
            except:
                cl("Can not open: %s" % self.logFilePath)
                f = None
        else:
            f = None
        return f

    def run(self):
        # print 'running'
        f = self.open_log_if_needed()
        while not self.quitFlag:
            # print 'before readline'
            err = self.fileD.readline()
            try:
                err = err.decode("gbk")
            except:
                try:
                    err = err.decode("utf8")
                except:
                    pass
                    # print 'after readline'
            if err == '':
                # print 'err is empty'
                self.quit()
            if err is None:
                self.quit()
                # print 'quit'
                break
            if self.output_to_console:
                # print 'got output:', self.appname, ':  ',err
                info(err)
                pass
            if not (f is None):
                try:
                    f.write(err)
                except:
                    pass
            self.target.updateViewCallback(err)
        if not (f is None):
            f.close()
        print 'quitting run: ', self.appname

    def quit(self):
        self.quitFlag = True


class ConsoleOutputCollector:
    """
    Create a console window and start a process. Collect the logs generated by the process.
    """
    normal_priority_tasks = ["webserver-cgi",
                             "startBeanstalkd.bat",
                             "mongodb.bat",
                             "cherrypyServerV4",
                             "monitorServiceV2"
                             ]

    def __init__(self, log_root_path=None, python_executable=None):
        self.log_collector_thread_list = []
        self.pList = []
        self.stopped = False
        self.log_root_path = log_root_path
        self.python_executable = python_executable

    def get_python_executable(self):
        if self.python_executable is None:
            possible_python_exe_path = []
            # print os.environ
            try:
                possible_python_exe_path.append(sys.executable)
                possible_python_exe_path.append(os.path.join(os.environ['VIRTUAL_ENV'], 'Scripts/pythonw.exe'))
                # print 'using virtual env:', pythonWinPathList[0], progAndParam
            except:
                pass
            possible_python_exe_path.extend(
                ['c:/Python27/pythonw.exe', 'd:/python27/pythonw.exe', 'd:/python25/pythonw.exe',
                 'c:/python27/pythonw.exe', 'c:/python26/pythonw.exe', 'c:/python25/pythonw.exe'])
            for i in possible_python_exe_path:
                if os.path.exists(i):
                    target_python_executable = i
                    break
                else:
                    # print i, ", does not exist"
                    pass
        else:
            target_python_executable = self.python_executable
        return target_python_executable

    def run_app_in_window(self, target, cwd, app_or_script_path_and_param_list):
        checkExistPath = app_or_script_path_and_param_list
        if type(checkExistPath) == list:
            checkExistPath = checkExistPath[0]
            if not os.path.exists(checkExistPath):
                # Do not execute if the file does not exist
                return
        self.cwd = cwd
        if not (os.path.exists(self.cwd)):
            print 'execution path does not exist: ', self.cwd
        self.progAndParm = app_or_script_path_and_param_list

        try:
            target.set_title(str(app_or_script_path_and_param_list))
        except:
            traceback.print_exc()
            print "set title not supported"
            # print target
        # print '-------------------------',app_or_script_path_and_param_list
        # print cwd
        # self.real_execute_path_and_param_list = ['D:\\cygwin\\bin\\ls.exe','-l']
        ext = os.path.splitext(checkExistPath)[1]
        # print 'ext is:', ext

        if ".py" == ext:
            target_python_executable = self.get_python_executable()
            self.real_execute_path_and_param_list = [target_python_executable, '-u']
            self.real_execute_path_and_param_list.extend(app_or_script_path_and_param_list)  # Param 2 is the app
        else:
            self.real_execute_path_and_param_list = []
            self.real_execute_path_and_param_list.extend(app_or_script_path_and_param_list)
        print self.real_execute_path_and_param_list
        if True:  # try:
            # print self.real_execute_path_and_param_list
            if not os.path.exists(self.real_execute_path_and_param_list[0]):
                print "path does not exist: ", self.real_execute_path_and_param_list[0]
            p = subprocess.Popen(self.real_execute_path_and_param_list, cwd=self.cwd, stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE, bufsize=0,
                                 creationflags=CREATE_NO_WINDOW)
            self.pList.append(p)
            # print "created pid:", p.pid

            find_flag = False
            for z in self.normal_priority_tasks:
                if app_or_script_path_and_param_list[0].find(z) != -1:
                    # Need normal priority for this app
                    find_flag = True
            if not find_flag:
                sysprocess.set_priority(p.pid, 1)
                pass
                # print "setting pid: %d, %s to below normal priority"%(p.pid, app_or_script_path_and_param_list[0])
            else:
                # print "pid: %d, %s use normal priority"%(p.pid, app_or_script_path_and_param_list[0])
                pass
                # print 'taskid:%d, pid:%d'%(int(p._handle), int(p.pid))

            log_path_base_name = os.path.basename(
                app_or_script_path_and_param_list[0])  # + str(app_or_script_path_and_param_list[1:])
            normal_log_path = logDir.logDir(log_path_base_name + "_normal", self.log_root_path)
            err_log_path = logDir.logDir(log_path_base_name + "_error", self.log_root_path)
            thr1 = ConsoleCollectWorkerThread(target, p.stdout, app_or_script_path_and_param_list[0],
                                              False, normal_log_path.getLogFilePath())
            thr1.start()
            self.log_collector_thread_list.append(thr1)
            thr2 = ConsoleCollectWorkerThread(target, p.stderr, app_or_script_path_and_param_list[0],
                                              True, err_log_path.getLogFilePath())
            thr2.start()
            self.log_collector_thread_list.append(thr2)
            # print 'launch ok'
        else:  # except:
            print 'launch exception'
            # self.appStarted = True

    def kill_console_process_tree(self):
        # TODO: do we need to kill applications?
        for i in self.pList:
            print 'processing:', i.pid, ", handle: ", int(i._handle)
            # print "cmd:", self.progAndParm
            sysprocess.killChildProcessTree(i.pid)
            sysprocess.TerminateProcess(i)
        for i in self.log_collector_thread_list:
            i.quit()

    def send_stop_signal(self):
        pass
